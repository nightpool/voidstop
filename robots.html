<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Robots</title>
    <style>
      body, html {
        margin: 0;
        padding: 0;
      }
      .container {
        display: grid;
        min-height: 100vh;
        grid-template-columns: 1fr auto 1fr;
      }
      #board {
        width: 90vmin;
        height: 90vmin;
        margin: auto;
      }
      #left, #right {
        white-space: pre-wrap;
        margin: 2rem 0;
      }
    </style>
</head>
<body>
  <div class="container">
    <div id="left"></div>
    <canvas id="board"></canvas>
    <div id="right"></div>
  </div>
  <script>
    const BOARD = {
      size: 8,
      walls: [[[-7,-7],[-8,-7]],[[-7,-7],[-7,-8]],[[-6,-5],[-6,-6]],[[-6,-5],[-7,-5]],[[-7,-4],[-8,-4]],[[-8,-3],[-8,-4]],[[-7,0],[-7,1]],[[-5,-2],[-6,-2]],[[-5,-1],[-5,-2]],[[-3,0],[-3,-1]],[[-4,-4],[-4,-5]],[[-3,-5],[-4,-5]],[[0,-4],[-1,-4]],[[-2,-6],[-2,-7]],[[-1,-6],[-2,-6]],[[-4,1],[-5,1]],[[-5,1],[-5,2]],[[-6,4],[-6,5]],[[-6,5],[-7,5]],[[-7,7],[-8,7]],[[-7,7],[-7,8]],[[-4,6],[-4,7]],[[-3,7],[-4,7]],[[-1,3],[-2,3]],[[-1,3],[-1,4]],[[0,2],[-1,2]],[[1,3],[1,4]],[[1,4],[2,4]],[[0,6],[1,6]],[[2,0],[2,1]],[[3,7],[4,7]],[[4,6],[4,7]],[[4,1],[5,1]],[[5,1],[5,2]],[[5,5],[5,6]],[[5,5],[6,5]],[[7,7],[7,8]],[[7,7],[8,7]],[[7,-7],[7,-8]],[[7,-7],[8,-7]],[[5,-5],[6,-5]],[[6,-4],[6,-5]],[[4,-3],[5,-3]],[[4,-2],[4,-3]],[[4,0],[4,-1]],[[2,-3],[3,-3]],[[2,-3],[2,-4]],[[3,-5],[4,-5]],[[4,-5],[4,-6]],[[0,-6],[1,-6]]],
      reflectors: [
        {
          pos: [ 8,  8],
          slope: -1,
          color: 'silver',
        },
        {
          pos: [-8,  8],
          slope: 1,
          color: 'silver',
        },
        {
          pos: [ 8, -8],
          slope: 1,
          color: 'silver',
        },
        {
          pos: [-8, -8],
          slope: -1,
          color: 'silver',
        }
      ],
      robots: [
        [-3, -4],
        [5, -2],
      ],
    };
    const ROBOT_COLORS = [
      'red',
      'green',
      'aqua',
      'yellow',
      'silver',
    ]
  </script>
  <script>
    const TAU = 2*Math.PI;
    const range = n => [...new Array(n)].map((_, i) => i);
    const context = board.getContext('2d', {
      desynchronized: true,
      alpha: false,
    });
    context.imageSmoothingQuality = 'high';

    const withContext = (func) => {
      context.save();
      Object.assign(context, props);
      func();
      context.restore();
    };

    const stroke = (props) => {
      context.save();
      context.resetTransform();
      context.scale(devicePixelRatio, devicePixelRatio);
      Object.assign(context, props);
      context.stroke();
      context.restore();
    };

    const boardTo = (x, y) => {
      const inverse = boardTransform.inverse();
      return [
        x * inverse.a + y * inverse.c + inverse.e,
        x * inverse.b + y * inverse.d + inverse.f,
      ]
    }
    
    let effectiveSize = BOARD.size + 1;
    let boardTransform;
    let editingWallSection;
    let scheduledFrame;
    const draw = () => {
      scheduledFrame = false;

      board.width = board.clientWidth * devicePixelRatio;
      board.height = board.clientHeight * devicePixelRatio;

      context.save();
      context.fillStyle = 'white';
      context.fillRect(0, 0, board.width, board.height);

      context.scale(board.width / (effectiveSize * 2), board.height / (effectiveSize * 2));
      context.translate(effectiveSize, effectiveSize);
      boardTransform = context.getTransform().invertSelf().scaleSelf(2);

      context.beginPath();
      context.moveTo(0, -BOARD.size);
      context.lineTo(0,  BOARD.size);
      context.moveTo(-BOARD.size, 0);
      context.lineTo( BOARD.size, 0);
      stroke({lineWidth: '4'});

      context.beginPath();
      for (var x = -BOARD.size; x <= BOARD.size; x++) {
        context.moveTo(x, -BOARD.size);
        context.lineTo(x,  BOARD.size);
      }

      for (var y = -BOARD.size; y <= BOARD.size; y++) {
        context.moveTo(-BOARD.size, y);
        context.lineTo( BOARD.size, y);
      }
      stroke({lineWidth: '1'});

      context.beginPath();
      for (const {pos: [x, y], slope} of BOARD.reflectors) {
        const centerX = x - 0.5 * Math.sign(x);
        const centerY = y - 0.5 * Math.sign(y);
        context.moveTo(
          centerX + 0.5, (slope * +0.5) + centerY
        )
        context.lineTo(
          centerX - 0.5, (slope * -0.5) + centerY
        )

        stroke({lineWidth: '4', strokeStyle: 'silver'});
      }

      context.beginPath();
      BOARD.robots.forEach(([x, y], i) => {
        const centerX = x - 0.5 * Math.sign(x);
        const centerY = y - 0.5 * Math.sign(y);
        context.beginPath();
        context.moveTo(centerX, centerY);
        context.arc(centerX, centerY, 0.4, 0, TAU);

        context.moveTo(x, y);
        context.arc(x, y, 0.1, 0, TAU);
        context.fillStyle = ROBOT_COLORS[i];
        context.save();
        context.resetTransform();
        context.scale(devicePixelRatio, devicePixelRatio);
        context.font = '16px monospace';
        const [origX, origY] = boardTo(x, y - .3);
        context.fillText(`(${x}, ${y})`, origX, origY - .3);
        context.restore();
        context.fill();
      });
      
      if (editingWallSection) {
        context.beginPath();

        const [start, end] = editingWallSection;
        context.moveTo(...start);
        context.lineTo(...end);

        stroke({lineWidth: '4', strokeStyle: 'blue'});
      }

      context.beginPath();
      for (const [start, end] of BOARD.walls) {
        context.moveTo(...start);
        context.lineTo(...end);
      }
      stroke({lineWidth: '4'});

      context.restore();
    }
    const debouncedDraw = () => {
      if (!scheduledFrame) {
        scheduledFrame = true;
        requestAnimationFrame(draw);
      }
    }
    draw();

    let selectedRobot = 0;
    document.addEventListener('keydown', (event) => {
      switch(event.key){
        case 'ArrowUp': {
          move(0, -1);
          break;
        }
        case 'ArrowDown': {
          move(0, 1);
          break;
        }
        case 'ArrowRight': {
          move(1, 0);
          break;
        }
        case 'ArrowLeft': {
          move(-1, 0);
          break;
        }
        case '1': case '2': case '3':
        case '4': case '5': {
          selectedRobot = Number(event.key) - 1;
          break;
        }
        default: {
          console.error(event.key);
          break;
        }
      }
    });

    const xWalls = range(effectiveSize).map(i =>
      range(effectiveSize).map(j => j === 0 ? 1 : 0));
    const absMax = (n, m) => Math.abs(n) > Math.abs(m) ? n : m;
    // BOARD.walls
    //   .filter(([w1, w2]) => w1[0] == w2[0])
    //   .forEach(([w1, w2]) => xWalls[w1[0]][absMax(w1[1], w1[2])]);

    const yWalls = range(effectiveSize).map(i =>
      range(effectiveSize).map(j => j === 0 ? true : false));
    const move = (x, y) => {
      BOARD.robots[selectedRobot][0] += x;
      BOARD.robots[selectedRobot][1] += y;
      debouncedDraw();
    }

    Object.defineProperty(Object.prototype, 'tap',
      { value: tap, configurable: true, writable: true }
    );
    const AsyncFunction = (async () => {}).constructor;

    function tap(f) {
      if (f instanceof AsyncFunction) {
        return f(this).then(() => this);
      } else {
        f(this); return this;
      }
    };
  </script>
</body>
</html>