<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Robots</title>
    <style>
      body, html {
        margin: 0;
        padding: 0;
      }
      .container {
        display: grid;
        min-height: 100vh;
        grid-template-columns: 1fr auto 1fr;
      }
      #board {
        width: 90vmin;
        height: 90vmin;
        margin: auto;
      }
      #left, #right {
        white-space: pre-wrap;
        margin: 2rem 0;
      }
    </style>
</head>
<body>
  <div class="container">
    <div id="left"></div>
    <canvas id="board"></canvas>
    <div id="right"></div>
  </div>
  <script>
    const BOARD = {
      walls: [[[-7,-7],[-8,-7]],[[-7,-7],[-7,-8]],[[-6,-5],[-6,-6]],[[-6,-5],[-7,-5]],[[-7,-4],[-8,-4]],[[-8,-3],[-8,-4]],[[-7,0],[-7,1]],[[-5,-2],[-6,-2]],[[-5,-1],[-5,-2]],[[-3,0],[-3,-1]],[[-4,-4],[-4,-5]],[[-3,-5],[-4,-5]],[[0,-4],[-1,-4]],[[-2,-6],[-2,-7]],[[-1,-6],[-2,-6]],[[-4,1],[-5,1]],[[-5,1],[-5,2]],[[-6,4],[-6,5]],[[-6,5],[-7,5]],[[-7,7],[-8,7]],[[-7,7],[-7,8]],[[-4,6],[-4,7]],[[-3,7],[-4,7]],[[-1,3],[-2,3]],[[-1,3],[-1,4]],[[0,2],[-1,2]],[[1,3],[1,4]],[[1,4],[2,4]],[[0,6],[1,6]],[[2,0],[2,1]],[[3,7],[4,7]],[[4,6],[4,7]],[[4,1],[5,1]],[[5,1],[5,2]],[[5,5],[5,6]],[[5,5],[6,5]],[[7,7],[7,8]],[[7,7],[8,7]],[[7,-7],[7,-8]],[[7,-7],[8,-7]],[[5,-5],[6,-5]],[[6,-4],[6,-5]],[[4,-3],[5,-3]],[[4,-2],[4,-3]],[[4,0],[4,-1]],[[2,-3],[3,-3]],[[2,-3],[2,-4]],[[3,-5],[4,-5]],[[4,-5],[4,-6]],[[0,-6],[1,-6]]],
      reflectors: [
        {
          pos: [ 8,  8],
          slope: -1,
          color: 'silver',
        },
        {
          pos: [-8,  8],
          slope: 1,
          color: 'silver',
        },
        {
          pos: [ 8, -8],
          slope: 1,
          color: 'silver',
        },
        {
          pos: [-8, -8],
          slope: -1,
          color: 'silver',
        }
      ],
      robots: [
        [-3, -4],
        [-3, -4],
      ]
    }
  </script>
  <script>
    const TAU = 2*Math.PI;
    const range = n => [...new Array(n)].map((_, i) => i);
    const context = board.getContext('2d', {
      desynchronized: true,
      alpha: false,
    });
    context.imageSmoothingQuality = 'high';

    const withContext = (func) => {
      context.save();
      Object.assign(context, props);
      func();
      context.restore();
    };

    const stroke = (props) => {
      context.save();
      context.resetTransform();
      context.scale(devicePixelRatio, devicePixelRatio);
      Object.assign(context, props);
      context.stroke();
      context.restore();
    };
    
    const wallKey = wall => wall.map(i => i.join(":")).join("|");
    const walls = new Map(BOARD.walls.map(i => [wallKey(i), i]));
    let boardTransform;
    let editingWallSection;
    let scheduledFrame;
    const draw = () => {
      scheduledFrame = false;

      board.width = board.clientWidth * devicePixelRatio;
      board.height = board.clientHeight * devicePixelRatio;

      context.save();
      context.fillStyle = 'white';
      context.fillRect(0, 0, board.width, board.height);

      context.scale(board.width / 18, board.height / 18);
      context.translate(9, 9);
      boardTransform = context.getTransform().invertSelf().scaleSelf(2);

      context.beginPath();
      context.moveTo(0, -8);
      context.lineTo(0,  8);
      context.moveTo(-8, 0);
      context.lineTo( 8, 0);
      stroke({lineWidth: '4'});

      context.beginPath();
      for (var x = -8; x <= 8; x++) {
        context.moveTo(x, -8);
        context.lineTo(x,  8);
      }

      for (var y = -8; y <= 8; y++) {
        context.moveTo(-8, y);
        context.lineTo( 8, y);
      }
      stroke({lineWidth: '1'});

      context.beginPath();
      for (const {pos: [x, y], slope} of BOARD.reflectors) {
        const centerX = x - 0.5 * Math.sign(x);
        const centerY = y - 0.5 * Math.sign(y);
        context.moveTo(
          centerX + 0.5, (slope * +0.5) + centerY
        )
        context.lineTo(
          centerX - 0.5, (slope * -0.5) + centerY
        )

        stroke({lineWidth: '4', strokeStyle: 'silver'});
      }


      
      if (editingWallSection) {
        context.beginPath();

        const [start, end] = editingWallSection;
        context.moveTo(...start);
        context.lineTo(...end);

        stroke({lineWidth: '4', strokeStyle: 'blue'});
      }

      context.beginPath();
      for (const [start, end] of walls.values()) {
        context.moveTo(...start);
        context.lineTo(...end);
      }
      stroke({lineWidth: '4'});

      context.restore();
    }
    const debouncedDraw = () => {
      if (!scheduledFrame) {
        scheduledFrame = true;
        requestAnimationFrame(draw);
      }
    }
    draw();

    let mouseCoordinates;
    board.addEventListener('mousemove', ({offsetX, offsetY}) => {
      const x = offsetX * boardTransform.a + offsetY * boardTransform.c + boardTransform.e;
      const y = offsetX * boardTransform.b + offsetY * boardTransform.d + boardTransform.f;
      mouseCoordinates = [x, y];
      editingWallSection = closestGridLine(x, y);
      debouncedDraw();
    });

    board.addEventListener('mouseout', event => {
      editingWallSection = null;
      debouncedDraw();
    });

    board.addEventListener('click', event => {
      if (editingWallSection) {
        const key = editingWallSection.map(i => i.join(":")).join("|");
        walls.has(key) ?
          walls.delete(key) :
          walls.set(key, editingWallSection);

        debouncedDraw();
      }
    })

    const closestGridBox = (mouseX, mouseY) => [
      Math.round(mouseX - 0.5) + 0.5,
      Math.round(mouseY - 0.5) + 0.5,
    ];

    const closestGridLine = (mouseX, mouseY) => {
      const roundX = Math.round(mouseX);
      const roundY = Math.round(mouseY);
      const xFPart = Math.abs(mouseX - Math.round(mouseX));
      const yFPart = Math.abs(mouseY - Math.round(mouseY));

      if (xFPart <= yFPart && xFPart < .25) {
        return [
          [roundX, Math.trunc(mouseY)],
          [roundX, Math.trunc(mouseY) + Math.sign(mouseY)],
        ];
      } else if (yFPart < .25) {
        return [
          [Math.trunc(mouseX), roundY],
          [Math.trunc(mouseX) + Math.sign(mouseX), roundY],
        ];
      }
    }

    Object.defineProperty(Object.prototype, 'tap',
      { value: tap, configurable: true, writable: true }
    );
    const AsyncFunction = (async () => {}).constructor;

    function tap(f) {
      if (f instanceof AsyncFunction) {
        return f(this).then(() => this);
      } else {
        f(this); return this;
      }
    };
  </script>
</body>
</html>